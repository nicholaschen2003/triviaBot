import os
import discord
import re
import time
import asyncio
import json
import random
from difflib import SequenceMatcher
from dotenv import load_dotenv
from openai import OpenAI

load_dotenv()

TOKEN = os.getenv('DISCORD_TOKEN')
client2 = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))

intents = discord.Intents.default()
intents.message_content = True

client = discord.Client(intents=intents)

def check(ans):
    def inner_check(message):
        return (SequenceMatcher(None, message.content.lower(), ans.lower()).ratio() >= 0.8)
    return inner_check

SYMBOL = ">"
CATEGORIES = [x.split(".")[0] for x in os.listdir("categories")]
TIMEOUT = 15
DELAY = 5

functions = [
    {
        "name": "add_new_question",
        "description": "add a NEW question to the database. It must have a single valid answer, not multiple",
        "parameters": {
            "type": "object",
            "properties": {
                "question": {
                    "type": "string",
                    "description": "NEW question body text to add",
                },
                "answer": {
                    "type": "string",
                    "description": "NEW answer to the question. Must be a single string, not multiple answers.",
                },
            },
            "required": ["question", "answer"],
        },
    }
]

with open("rankings.json") as json_file:
    RANKINGS = json.load(json_file)

@client.event
async def on_ready():
    print(f'Logged on as {client.user}!')

@client.event
async def on_message(message):
    global CATEGORIES
    global TIMEOUT
    global DELAY
    global RANKINGS
    global SYMBOL
    if message.author.id == client.user.id:
        return

    elif message.content == f'{SYMBOL}categories':
        await message.channel.send("\n".join(CATEGORIES))

    elif x := re.search(f'{SYMBOL}hintdelay (\d*)', message.content):
        TIMEOUT = int(x.group(1))
        await message.channel.send(f"Delay between hints is now {TIMEOUT} seconds!")

    elif x := re.search(f'{SYMBOL}qdelay (\d*)', message.content):
        DELAY = int(x.group(1))
        await message.channel.send(f"Delay between questions is now {DELAY} seconds!")

    elif x := re.search(f'{SYMBOL}start questions (\d*) category (.*)', message.content):
        if x.group(2).lower() in CATEGORIES:
            f = open(f"categories/{x.group(2).lower()}.txt", 'r')
            lines = f.readlines()
            qas = [(lines[i].strip(), lines[i+1].strip()) for i in range(0, len(lines), 2)]
            qas2 = [x for x in qas]
            print(qas, x.group(1), x.group(2))
            question_count = -1
            sub_qas = random.sample(qas, min(int(x.group(1)), len(qas)))

            await message.channel.send(f"Starting game with {x.group(1)} questions and category {x.group(2)}")

            if len(qas) < int(x.group(1)):
                await message.channel.send(f"**Warning**: not enough local questions, final {int(x.group(1))-len(qas)} question(s) will be generated by AI.")

            while question_count < int(x.group(1)):
                question_count += 1
                if len(sub_qas) == 0:
                    response = client2.chat.completions.create(
                        model="gpt-3.5-turbo",
                        messages=[
                            {"role": "system", "content": "Here are the current questions!"},
                            {"role": "system", "content": "\n".join(["Question: " + qa[0] + " Answer: " + qa[1] for qa in qas2])},
                            {"role": "system", "content": "Please generate another like them. The category is " + x.group(2) + "."}
                        ],
                        function_call={"name": "add_new_question"},
                        functions=functions
                    )
                    args = json.loads(response.choices[0].message.function_call.arguments)
                    tup = (args["question"], args["answer"])
                    qas2.append(tup)
                    sub_qas.append(tup)
                    await message.channel.send("**Warning**: AI generated question.")


                i = question_count
                qa = sub_qas.pop()
                for j in range(4):
                    if j == 0:
                        await message.channel.send(f"Question {i+1}: {qa[0]}")
                        ans = qa[1]
                        start = time.time()
                    elif j == 1:
                        await message.channel.send("Hint 1: " + re.sub(r'\w', "\_", ans))
                    elif j == 2:
                        await message.channel.send("Hint 2, scrambled: " + "".join(random.sample(ans, len(ans))))
                    elif j == 3:
                        s = ""
                        for word in ans.split(" "):
                            s += ''.join("\_" if i % 2 == 0 else char for i, char in enumerate(word, 1))
                            s += " "
                        await message.channel.send("Hint 3: " + s)
                    try:
                        msg = await client.wait_for('message', check=check(ans), timeout=TIMEOUT)
                    except asyncio.TimeoutError:
                        if j == 3:
                            await message.channel.send(f"Time's up! Correct answer was: {ans}")
                    else:
                        elapsed = time.time() - start
                        await message.channel.send(f"Correct answer: \"{ans}\".\n{msg.author} correctly answered \"{msg.content}\" in {elapsed:.2f} seconds, earning {5 - j} points!")
                        if str(msg.author) in RANKINGS.keys():
                            RANKINGS[str(msg.author)] += 5 - j
                        else:
                            RANKINGS[str(msg.author)] = 5 - j
                        RANKINGS = dict(sorted(RANKINGS.items(), key=lambda item: item[1], reverse=True))
                        with open("rankings.json", "w") as outfile:
                            json.dump(RANKINGS, outfile)
                        break
                if j != 3:
                    await asyncio.sleep(DELAY)
            await message.channel.send("End of game!")
            ranks = "\n".join([f"{x}: {y}" for x, y in RANKINGS.items()])
            await message.channel.send(f"Rankings:\n{ranks}")

        else:
            await message.channel.send(f"Category not found, valid options are:\n{CATEGORIES}")

    elif message.content == f'{SYMBOL}rankings':
        ranks = "\n".join([f"{x}: {y}" for x, y in RANKINGS.items()])
        await message.channel.send(f"Rankings:\n{ranks}")

    elif message.content == f'{SYMBOL}resetrankings':
        RANKINGS = {}
        with open("rankings.json", "w") as outfile: 
            json.dump(RANKINGS, outfile)
        await message.channel.send(f"Rankings have been reset!")

    elif x := re.search(f'{SYMBOL}prefix (.*)', message.content):
        SYMBOL = x.group(1)
        await message.channel.send(f"Prefix is now: {SYMBOL}")
        
client.run(TOKEN)